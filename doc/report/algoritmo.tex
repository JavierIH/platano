\section{Algoritmo}
\label{algoritmo}

En esta sección se presenta el algoritmo que se ha implementado para el caso de uso que se ha tratado. El algoritmo se puede ver en el flujograma de la figura \ref{fig:flujo_algoritmo}. \\

\comment{Insertar flujograma!}\\

En primer lugar se procesa la imagen obtenida del escenario (mapa) para extraer los obstáculos. A continuación, se generan los puntos (muestras) que corresponderán a los nodos del roadmap y se conectan siguendo un criterio de distancias. Por último, cuando un punto inicial y un punto final son pedidos, se incluyen en el grafo y se calcula el camino más corto mediante un algoritmo de búsqueda en grafos, tal como el Djisktra o el $A^*$.\\

\subsection{Procesamiento del mapa}

A partir de la imagen del escenario capturada desde el simulador, se realiza un procesamiento de la misma usando técnicas de visión por computador. Se comienza por realizar un umbralizado de manera que el resultado es una imagen binaria en la que los obstáculos son píxeles blancos y el espacio libre píxeles negros. \\

A la imagen binaria se le realiza un etiquetado de objetos para obtener los contornos de los distintos obstáculos, los cuales son posteriormente simplificados para reducir el número de puntos que definen el obstáculo, mejorando la eficiencia del algoritmo de detección de colisiones.\\

Estos contornos que definen a los obstáculos son usados en posteriores partes del algoritmo. En la figura \ref{fig:procesado_imagen} se especifica el diagrama de flujo del procesamiento del mapa.


\subsection{Muestreo del espacio libre}

El siguiente paso para la generación del roadmap es el muestreo del espacio libre. En el algoritmo original este muestreo se realiza de forma aleatoria, generando nodos del roadmap repartidos aleatoriamente por todo el entorno. La mejora que introduce el artículo que es objeto de estudio con este caso práctico es la generación de dicho muestreo a partir de conjuntos de puntos cuasi-aleatorios. Estas distribuciones de puntos tienen la ventaja de ocupar el espacio libre de forma más eficiente, por lo que con menos cantidad de puntos se puede abarcar un área mayor y, por tanto, más partes delicadas del mapa. Estas partes delicadas pueden ser, por ejemplo, estrechamientos del espacio libre entre obstáculos. Los autores del artículo dan una medida de la ocupación eficiente del espacio libre con un parámetro que ellos llaman \textit{discrepancia}:\\




 \[ D_N(P) = \sup_{j}{\left| \frac{A(J)}{N} -  \mu(J) \right| }\]\\

En la que P es un conjunto de N puntos d-dimensionales, $\left\lbrace x_0, ... , x_{N-1} \right\rbrace$ en $[0,1]^d$, J es cualquier subconjunto rectangular de $[0,1]^d$, $\mu()$ es su \comment{measure} y A(J) es el número de puntos contenido en $P \cap J$.\\

Para el muestreo de puntos cuasi-aleatorios hemos usado dos distribuciones de puntos: el conjunto de Hammersley y el conjunto de Halton. Estas distribuciones se generan a partir de una semilla para un número arbitrario de dimensiones. Estas distribuciones se pueden calcular de la siguiente manera:

\subsubsection{Conjunto de Hammersley}

Dados $d-1$ números primos distintos $p_1, p_2, ... , p_{d-1}$ el i-ésimo punto del conjunto es dado por la expresión:

\[ \left( \frac{i}{N}, r_{p_1}(i), ..., r_{p_{d-1}(i)} \right), \qquad i = 0, 1, ..., N-1\]

\subsubsection{Conjunto de Halton}

Dados $d$ números primos distintos $p_1, p_2, ..., p_d$ el i-ésimo punto del conjunto es dado por la siguiente expresión:

\[ \left( r_{p_1}(i),  r_{p_2}(i), ...,  r_{p_d}(i) \right) \]\\~\\

%\subsubsection{Función $r_p(i)$}
En ambos casos, la función $r_p(i)$ se obtiene  escribiendo los dígitos de la notación basada en $p$ en orden inverso. Por ejemplo, para la expresión $i = a_0 + a_1 p + a_2 p^2 + a_3 p^3 + ... $ donde $a_j \in \left\lbrace 0, 1, ... , p-1 \right\rbrace$ la función $r_p(i)$ sería:

\[ r_p(i) = \frac{a_0}{p} + \frac{a_1}{p^2} + \frac{a_2}{p^3} + \frac{a_3}{p^4} + ...\]

\coment{pasarlo a impersonal}\\

Para nuestra implementación hemos usado una biblioteca, perteneciente al paquete cgkit que nos proporcionaba estos conjuntos de puntos de manera cómoda y rápida, ahorrándonos tiempo de desarrollo y depuración de errores. La figura \ref{fig:muestreo} muestra una comparativa de los distintos métodos de generación de puntos de muestreo en un escenario ficticio.\\

\begin{figure}[b]
		\centering
        \begin{subfigure}[b]{0.3\textwidth}
                \centering
                \includegraphics[width=\textwidth]{images/random.png}
                \caption{Muestreo aleatorio}
                \label{fig:muestreo_aleatorio}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.3\textwidth}
                \centering
                \includegraphics[width=\textwidth]{images/hammersley.png}
                \caption{Muestreo con puntos Hammersley}
                \label{fig:muestreo_hammersley}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.3\textwidth}
         	   \centering
                \includegraphics[width=\textwidth]{images/halton.png}
                \caption{Muestreo con puntos Halton}
                \label{fig:muestreo_halton}
        \end{subfigure}
        \caption{Comparativa de los distintos modos de muestreo del espacio libre}\label{fig:muestreo}
\end{figure}

\subsection{Busqueda del camino más corto}

Una vez se ha muestreado el espacio libre y se han conectado los nodos entre si para generar un grafo, el siguiente paso es buscar el camino más corto. Para ello se ha decidido implementar dos algoritmos diferentes, el $A^*$ y el Dijkstra. De esta forma se puede realizar un estudio acerca de como afecta a los resultados obtenidos el método que se elija para encontrar la trayectoria óptima.\\

\subsubsection{Algoritmo $A^*$}

El algoritmo $A^*$ fue presentado por primera vez por P. Hart, N. Nilsson y B. Raphael, miembros del Stanford Research Institute, en 1968, como una evolución del algoritmo de Dijkstra. Busca devolver la trayectoria que vaya del nodo inicial al final y que presente un coste más bajo. Mientras va explorando un camino mantiene otras posibles soluciones para cambiar de trayectoria, en caso de que la que se está recorriendo deje de ser óptima. Este algoritmo garantiza que siempre se encontrará una solución, si existe alguna.\\

El coste que se emplea para comparar las distintas posibles trayectorias entre sí viene dado por la suma de dos funciones. La primera es la distancia recorrida entre el nodo inicial y el nodo para el cual se está calculando el coste, mientras que la segunda consiste en una estimación de la distancia que es necesario recorrer para llegar al punto de destino. Aunque esto último se puede representar de diversas maneras, lo mas común es calcular la distancia en linea recta desde el nodo actual hasta el final.\\

A continuación se muestra el pseudocódigo que describe el algoritmo $A^*$ tal y como se ha implementado en este trabajo:\\

\begin{algorithm}
\caption{$A^*$ algorithm(start,target,distances,graph)}\label{A_algorithm}
\begin{algorithmic}[1]
\State openset = start
\State closedset = {}
\State path = {}
\State node_connection = {}
\While {openset != empty and current != start}
\ForAll{nodes in graph}
 \State Pick the current node neighbours
 \If{neighbour not in openset and not in closedset} 
 \State Calculate the cost value for that neighbour
 \State Add that neighbour to openset
 \State Add current,neighbour to node_connection
\EndFor
\State current = best node in openset
\State Add current to closedset and remove it from openset
\EndWhile
\If{exist path}
\While{current != start}
\State Add current to path
\State current = node_connection[current]
\EndWhile
\Else
\State path = {}
\EndIf
\State return path
\end{algorithmic}
\end{algorithm}  

Al algoritmo se le pasan cuatro parámetros. Start hace referencia al nodo de origen, target es el nodo de destino, graph es un vector donde se almacenan los diversos puntos con los que se ha muestreado el $C_free$ y, por último, dist es una matriz donde se almacena la distancia de cada nodo a todos los demás. Si esos nodos son vecinos la distancia será la separación entre puntos y si no lo son, vale -1.\\

El $A^*$ trabaja con dos subconjuntos de nodos. En openset se almacenarán los ultimos nodos sobre los que se está trabajando (el nodo actual y el último nodo considerado de cada una de las trayectorias alternativas) mientras que en closedset se irán guardando los nodos por los que ya se haya pasado. Además, en node_connection se almacena cada nodo del openset y el nodo contiguo en su trayectoria.\\

Se buscan los vecinos del nodo sobre el que se está trabajando, y, si no pertenecen ni a openset ni a closedset, se calcula su coste y se almacenan en openset. Una vez hecho esto, se elige al nodo de openset con menor coste y se pasa a trabajar sobre este. Este proceso se repite hasta que se llegue al nodo final o hasta que no queden nodos en openset.\\

Por último, si se ha encontrado un camino, se recorren los nodos almacenados en node_connection y se reconstruye el camino. Si no se ha encontrado una trayectoria posible